# Функциональное программирование

# Лабораторная работа №1

## Отчёт

Тема: Динамическое программирование

В ходе выполнения работы были решены задачи, требующие применения оптимальных алгоритмических подходов. Для понимания используемых методов важно отметить три ключевых теоретических понятия: динамическое программирование, асимптотическую сложность Big O и мемоизацию.

Динамическое программирование представляет собой метод решения задач путём разбиения их на подзадачи, результаты которых используются повторно. Такой подход эффективен тогда, когда задача обладает оптимальной подструктурой и перекрывающимися подзадачами. Это позволяет вычислять решение поэтапно, избегая лишних повторных вычислений, как, например, в задачах, связанных с подсчётом количества способов достижения определённого результата.

Нотация Big O используется для оценки того, как изменяется скорость работы алгоритма при увеличении размера входных данных. Она показывает, насколько быстро растёт количество операций и позволяет сравнивать разные алгоритмы по эффективности. Благодаря этому можно выбирать решения, которые работают быстрее на больших массивах данных. Например, линейная сложность O(n) обычно предпочтительнее квадратичной O(n²), поскольку требует значительно меньше времени.

Мемоизация является техникой оптимизации рекурсивных алгоритмов. Она заключается в сохранении результатов уже выполненных вычислений, чтобы при повторных обращениях не выполнять ту же работу повторно. Это особенно важно в задачах, где одни и те же значения рекурсивной функции вычисляются многократно. Благодаря мемоизации рекурсивные решения становятся значительно быстрее и подходят для задач с большими входными данными.

В целом при решении поставленных задач были использованы методы, позволяющие добиться высокой эффективности: анализ сложности через Big O, применение динамического программирования и использование мемоизации там, где это было целесообразно. Эти подходы позволили реализовать оптимальные решения, работающие за минимальное время.

## Решение задач

### Задача 1

Методология решения задачи «Climbing Stairs» заключалась в использовании динамического программирования: вычислялись способы для каждой ступени на основе двух предыдущих, с хранением только последних двух значений, что обеспечивало O(n) времени и O(1) памяти.

 <img width="648" height="636" alt="image" src="https://github.com/user-attachments/assets/9276287e-a9f7-449b-89ce-9203db82c2a8" />

Рисунок 1 – Решение задачи 1

### Задача 2
Для решения задачи использовался жадный алгоритм. На каждом шаге отслеживалось самое дальнее достижимое положение (farthest) и конец текущего прыжка (current_end). Когда текущая позиция достигала конца прыжка, счётчик прыжков увеличивался, а граница обновлялась до farthest. Такой подход позволил пройти массив за один проход, обеспечивая O(n) времени и O(1) памяти.
 <img width="720" height="657" alt="image" src="https://github.com/user-attachments/assets/dc576f94-6c05-4172-bf51-8bc6c2ee2254" />

Рисунок 2  – Решение задачи 2

### Задача 3
Для решения задачи использовалась итеративная формула биномиальных коэффициентов. Каждый элемент строки вычислялся на основе предыдущего с использованием формулы C(k)=C(k−1)∗(n−k+1)/k. Это позволило построить нужную строку напрямую, без вычисления всей треугольной структуры, обеспечив O(n) времени и O(1) дополнительной памяти.
 <img width="754" height="687" alt="image" src="https://github.com/user-attachments/assets/6579b57a-f908-4a9f-b541-632613ceaae5" />

Рисунок 3 – Решение задачи 3

### Задача 4
Для решения использовался однопроходный алгоритм. На каждом шаге отслеживалась минимальная цена покупки и вычислялась возможная прибыль при продаже на текущий день. Если прибыль была выше текущей максимальной, она обновлялась. Такой подход позволил найти максимальную прибыль за O(n) времени и O(1) памяти.
 <img width="743" height="697" alt="image" src="https://github.com/user-attachments/assets/a3acc35d-eb3e-48a4-bb47-58e433ca893c" />

Рисунок 4 – Решение задачи 4

### Задача 5 
Для решения использовался жадный алгоритм, учитывающий все возрастающие отрезки цен. На каждом шаге, если текущая цена выше предыдущей, разница добавлялась к общей прибыли. Таким образом фиксировались все возможные выгодные сделки, что позволяло получить максимальную прибыль за O(n) времени и O(1) памяти.
 <img width="773" height="708" alt="image" src="https://github.com/user-attachments/assets/22d81330-7ea9-44c8-ac47-bcb1ec3e0e61" />

Рисунок 5 – Решение задачи 5

